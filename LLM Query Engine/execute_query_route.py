"""
Execute SQL Query Route

This module provides an API endpoint for executing SQL queries directly against Snowflake.
It's designed to work with queries that were generated and then edited by users.
"""
import os
import time
import pandas as pd
from typing import Dict, List, Optional, Any, Union
from fastapi import APIRouter, HTTPException, Depends
from pydantic import BaseModel
from dotenv import load_dotenv

# Import SQL structure analysis tools
from sql_structure_utils import is_column_structure_changed, validate_read_only_sql

# Import chart recommendation tools
from chart_utils import generate_chart_recommendations_for_edited_sql

# Import Snowflake execution functionality
from snowflake_runner import execute_query as run_snowflake_query

# Import multi-client support
from config.client_integration import with_client_context
from config.client_manager import client_manager

# Load environment variables
load_dotenv()

# Create router
router = APIRouter()

class ExecuteQueryRequest(BaseModel):
    client_id: Optional[str] = "mts"  # Default to 'mts' client for backward compatibility
    query: str  # The SQL query to execute (can be an edited query)
    limit_rows: int = 100  # Maximum number of rows to return
    original_prompt: Optional[str] = None  # The original natural language prompt (for logging)
    include_charts: bool = False  # Whether to include chart recommendations
    model: Optional[str] = None  # Model used for original query generation
    original_sql: Optional[str] = None  # Original SQL before editing
    original_chart_recommendations: Optional[List[Dict[str, Any]]] = None  # Original chart recommendations

class ExecuteQueryResponse(BaseModel):
    query: str  # The executed SQL query
    query_output: List[Dict[str, Any]]  # Results of the query
    success: bool = True  # Whether the query executed successfully
    error_message: Optional[str] = None  # Error message if query failed
    execution_time_ms: Optional[float] = None  # Query execution time in milliseconds
    row_count: Optional[int] = None  # Number of rows returned
    original_prompt: Optional[str] = None  # Original prompt if provided
    edited: bool = True  # Flag indicating this was an edited query
    chart_recommendations: Optional[List[Dict[str, Any]]] = None  # Chart recommendations if applicable
    chart_error: Optional[str] = None  # Error message when charts cannot be generated

@router.post("/execute-query", response_model=ExecuteQueryResponse)
@with_client_context  # Apply client context switching
async def execute_query(request: ExecuteQueryRequest, data_dictionary_path: Optional[str] = None):
    """
    Execute a SQL query directly against Snowflake.
    
    This endpoint is designed for edited queries that were initially generated by the LLM.
    
    Args:
        request: The query request with the SQL to execute
        data_dictionary_path: Optional path to data dictionary (set by client context)
        
    Returns:
        ExecuteQueryResponse with query results or error information
    """
    start_time = time.time()
    
    try:
        # Validate query for read-only operations
        sql = request.query
        validation_result = validate_read_only_sql(sql)
        
        # If validation failed, return error response
        if validation_result is not True:
            error_msg = validation_result.get('error', 'SQL validation failed. Unknown error.')
            print(f"SQL validation error: {error_msg}")
            
            # Return error response without executing query
            return ExecuteQueryResponse(
                query=sql,
                query_output=[],
                success=False,
                error_message=error_msg,
                execution_time_ms=(time.time() - start_time) * 1000,
                row_count=0,
                original_prompt=request.original_prompt,
                edited=True,
                chart_recommendations=[],
                chart_error="Cannot generate charts due to SQL validation error"
            )
        
        # Add LIMIT if not present and limit_rows is specified
        if request.limit_rows > 0 and "LIMIT" not in sql.upper():
            # For SELECT statements without GROUP BY or aggregate functions, enforce LIMIT
            sql_upper = sql.upper()
            is_select = sql_upper.startswith("SELECT")
            has_group_by = "GROUP BY" in sql_upper
            has_aggregates = any(agg in sql_upper for agg in [" COUNT(", " SUM(", " AVG(", " MIN(", " MAX("])
            has_distinct = "DISTINCT" in sql_upper
            
            # If it's a SELECT without aggregation, enforce limit
            if is_select and not (has_group_by or has_aggregates or has_distinct):
                sql = f"{sql.rstrip('; \n')} LIMIT {min(request.limit_rows, 1000)}"
                print(f"\nAdded limit clause: LIMIT {min(request.limit_rows, 1000)}")
            else:
                # For other queries, respect the requested limit
                sql = f"{sql.rstrip('; \n')} LIMIT {request.limit_rows}"
                print(f"\nAdded limit clause: LIMIT {request.limit_rows}")
        elif "LIMIT" not in sql.upper():
            # If no limit specified and it's a simple SELECT, add default limit of 100
            sql_upper = sql.upper()
            is_select = sql_upper.startswith("SELECT")
            has_group_by = "GROUP BY" in sql_upper
            has_aggregates = any(agg in sql_upper for agg in [" COUNT(", " SUM(", " AVG(", " MIN(", " MAX("])
            has_distinct = "DISTINCT" in sql_upper
            
            if is_select and not (has_group_by or has_aggregates or has_distinct):
                sql = f"{sql.rstrip('; \n')} LIMIT 100"
                print("\nAdded default limit clause: LIMIT 100")
        
        print(f"\nExecuting SQL in Snowflake:\n{sql}")
        
        # Execute the query with client-specific credentials
        print(f"Executing SQL for client_id: {request.client_id}")
        df = run_snowflake_query(sql, print_results=True, client_id=request.client_id)
        
        # Calculate execution time
        execution_time_ms = (time.time() - start_time) * 1000
        
        # Convert DataFrame to list of dictionaries
        query_output = df.to_dict(orient="records") if not df.empty else []
        
        # Prepare response
        response = ExecuteQueryResponse(
            query=sql,
            query_output=query_output,
            success=True,
            execution_time_ms=execution_time_ms,
            row_count=len(df),
            original_prompt=request.original_prompt,
            edited=True,
            chart_recommendations=[],  # Empty by default
            chart_error=None
        )
        
        # Handle chart recommendations if requested
        if request.include_charts and not df.empty:
            try:
                # Intelligent chart recommendation handling
                if request.original_sql and request.original_chart_recommendations:
                    # Check if only filtering changed or if column structure changed
                    if not is_column_structure_changed(request.original_sql, sql):
                        # If only filters changed, reuse the original chart recommendations
                        print("SQL structure unchanged, reusing original chart recommendations")
                        response.chart_recommendations = request.original_chart_recommendations
                    else:
                        # Column structure changed, generate new recommendations using the same model
                        print("SQL structure changed, generating new chart recommendations")
                        chart_recommendations = generate_chart_recommendations_for_edited_sql(
                            sql=sql,
                            original_prompt=request.original_prompt,
                            model=request.model,
                            client_id=request.client_id
                        )
                        response.chart_recommendations = chart_recommendations
                else:
                    # No original chart recommendations available, generate new ones
                    print("No original chart recommendations available, generating new ones")
                    chart_recommendations = generate_chart_recommendations_for_edited_sql(
                        sql=sql,
                        original_prompt=request.original_prompt,
                        model=request.model,
                        client_id=request.client_id
                    )
                    response.chart_recommendations = chart_recommendations
            except Exception as e:
                response.chart_error = f"Error generating chart recommendations: {str(e)}"
        
        return response
        
    except Exception as e:
        # Calculate execution time even for errors
        execution_time_ms = (time.time() - start_time) * 1000
        
        error_msg = str(e)
        print(f"Error executing query: {error_msg}")
        
        # Return error response
        return ExecuteQueryResponse(
            query=request.query,
            query_output=[],
            success=False,
            error_message=error_msg,
            execution_time_ms=execution_time_ms,
            row_count=0,
            original_prompt=request.original_prompt,
            edited=True,
            chart_recommendations=[],
            chart_error="Cannot generate charts due to query execution error"
        )
